{% extends 'base.html' %}

{% block content %}
<wrapper class="block w-full">
    <div class="flex gap-6">

        <aside class="w-72 shrink-0 h-[45rem] bg-gray-900/60 border border-gray-800 rounded-2xl shadow-2xl p-4 overflow-y-auto">
            <div class="text-sm font-semibold text-gray-200 mb-3">Chats</div>

            <div class="mb-4">
                <a href="{% url 'chatroom' 'public-chat' %}"
                   class="block px-3 py-2 rounded-lg text-sm hover:bg-gray-800/60
                   {% if chat_group.group_name == 'public-chat' %}text-emerald-400 font-semibold{% else %}text-gray-300{% endif %}">
                    Public chat
                </a>
            </div>

            {% if sidebar_groupchats %}
                <div class="text-xs font-semibold text-gray-400 mb-2">Group chats</div>
                <ul class="space-y-1 mb-4">
                    {% for room in sidebar_groupchats %}
                        <li>
                            <a href="{% url 'chatroom' room.group_name %}"
                               class="block px-3 py-2 rounded-lg text-sm hover:bg-gray-800/60
                               {% if chat_group.group_name == room.group_name %}text-emerald-400 font-semibold{% else %}text-gray-300{% endif %}">
                                {{ room.groupchat_name|default:room.group_name|slice:":30" }}
                            </a>
                        </li>
                    {% endfor %}
                </ul>
            {% endif %}

            <div class="text-xs font-semibold text-gray-400 mb-2">Private rooms</div>
            <div class="space-y-2 mb-4">
                <form method="post" action="{% url 'private-room-create' %}" class="space-y-2">
                    {% csrf_token %}
                    {{ private_room_create_form.name }}
                    <button type="submit" class="w-full bg-gray-800 hover:bg-gray-700 text-white rounded-lg px-3 py-2 text-sm transition-colors">
                        Create private room
                    </button>
                </form>

                <form method="post" action="{% url 'private-room-join' %}" class="space-y-2">
                    {% csrf_token %}
                    {{ room_code_join_form.code }}
                    <button type="submit" class="w-full bg-gray-800 hover:bg-gray-700 text-white rounded-lg px-3 py-2 text-sm transition-colors">
                        Enter room code
                    </button>
                </form>
            </div>

            {% if sidebar_code_rooms %}
                <div class="text-xs font-semibold text-gray-400 mb-2">Your private rooms</div>
                <ul class="space-y-1 mb-4">
                    {% for room in sidebar_code_rooms %}
                        <li>
                            <a href="{% url 'chatroom' room.group_name %}"
                               class="block px-3 py-2 rounded-lg text-sm hover:bg-gray-800/60
                               {% if chat_group.group_name == room.group_name %}text-emerald-400 font-semibold{% else %}text-gray-300{% endif %}">
                                {{ room.code_room_name|default:room.room_code|slice:":30" }}
                            </a>
                        </li>
                    {% endfor %}
                </ul>
            {% endif %}

            {% if sidebar_privatechats %}
                <div class="text-xs font-semibold text-gray-400 mb-2">Direct</div>
                <ul class="space-y-1">
                    {% for room in sidebar_privatechats %}
                        <li>
                            <a href="{% url 'chatroom' room.group_name %}"
                               class="block px-3 py-2 rounded-lg text-sm hover:bg-gray-800/60
                               {% if chat_group.group_name == room.group_name %}text-emerald-400 font-semibold{% else %}text-gray-300{% endif %}">
                                {% for member in room.members.all %}
                                    {% if member != user %}
                                        {{ member.profile.name|default:member.username|slice:":30" }}
                                    {% endif %}
                                {% endfor %}
                            </a>
                        </li>
                    {% endfor %}
                </ul>
            {% endif %}
        </aside>

        <div id="chat_window" class="h-[45rem] flex flex-col bg-gray-900/60 border border-gray-800 rounded-2xl shadow-2xl relative p-1 grow">
        
        <div class="flex items-center justify-between text-emerald-400 bg-gray-900/60 p-2 sticky top-0 z-10 border-b border-gray-800 rounded-t-2xl">
            <div class="flex items-center">
                <span id="online-count" class="pr-1 font-bold">{{ chat_group.users_online.count }}</span> online
                {% if chat_group.is_code_room and chat_group.room_code %}
                    <span class="ml-3 text-xs text-gray-300">Room code: <span class="font-semibold text-emerald-400">{{ chat_group.room_code }}</span></span>
                {% endif %}
            </div>

            {% if chat_group.is_private %}
                <div class="flex items-center gap-2">
                    <a data-call-btn data-call-type="voice" href="#" class="text-xs bg-gray-800 hover:bg-gray-700 text-white px-3 py-1.5 rounded-lg transition-colors">
                        Voice call
                    </a>
                    <a data-call-btn data-call-type="video" href="#" class="text-xs bg-gray-800 hover:bg-gray-700 text-white px-3 py-1.5 rounded-lg transition-colors">
                        Video call
                    </a>
                </div>
            {% endif %}

            {% if chat_group.admin and user == chat_group.admin %}
                <form method="post" action="{% url 'chatroom-close' chatroom_name %}"
                      data-confirm="Close this room? This will delete the room and all messages/uploads."
                      data-confirm-title="Close room">
                    {% csrf_token %}
                    <button type="submit" class="text-xs bg-gray-800 hover:bg-gray-700 text-white px-3 py-1.5 rounded-lg transition-colors">
                        Close room
                    </button>
                </form>
            {% endif %}
        </div>

        <div id='chat_container' class="overflow-y-auto grow p-4">
            <ul id='chat_messages' class="flex flex-col justify-end gap-2">
                {% for message in chat_messages %}
                    {% include 'a_rtchat/chat_message.html' %}
                {% endfor %}
            </ul>
        </div>

        <div class="sticky bottom-0 z-10 p-4 bg-gray-900/60 border-t border-gray-800 rounded-b-2xl">
            <div id="reply_bar" class="hidden mb-2 rounded-xl border border-gray-800 bg-gray-900/80 px-3 py-2">
                <div class="flex items-start justify-between gap-3">
                    <div class="min-w-0">
                        <div class="text-[10px] font-semibold text-emerald-400">Replying to <span id="reply_bar_author" class="text-gray-200"></span></div>
                        <div id="reply_bar_preview" class="text-[11px] text-gray-400 truncate"></div>
                    </div>
                    <button type="button" id="reply_bar_cancel" class="text-gray-300 hover:text-white px-2">×</button>
                </div>
            </div>

            <div id="edit_bar" class="hidden mb-2 rounded-xl border border-gray-800 bg-gray-900/80 px-3 py-2">
                <div class="flex items-start justify-between gap-3">
                    <div class="min-w-0">
                        <div class="text-[10px] font-semibold text-emerald-400">Editing message</div>
                        <div id="edit_bar_preview" class="text-[11px] text-gray-400 truncate"></div>
                    </div>
                    <button type="button" id="edit_bar_cancel" class="text-gray-300 hover:text-white px-2">×</button>
                </div>
            </div>

            <div id="typing_indicator" class="hidden mb-2 text-[11px] text-gray-400">
                <span id="typing_indicator_text"></span>
            </div>

            <form id="chat_message_form" class="flex items-center gap-2"
                hx-post="{{ request.path }}"
                hx-target="#chat_messages"
                hx-swap="none"
                hx-on:htmx:after-request="document.getElementById('id_body').value = ''; document.getElementById('reply_to_id').value=''; document.getElementById('reply_bar').classList.add('hidden'); scrollToBottom();">
                {% csrf_token %}

                <input type="hidden" name="reply_to_id" id="reply_to_id" value="" />

                {{ form.body }} <button type="submit" class="bg-emerald-500 hover:bg-emerald-600 text-white rounded-lg px-4 py-2 transition-colors">
                    Send
                </button>
            </form>

            {% if chat_group.is_private and chat_group.is_code_room %}
                <div class="mt-3">
                    <form id="chat_file_form"
                          class="flex items-center gap-2"
                          hx-post="{% url 'chat-file-upload' chatroom_name %}"
                          hx-target="#upload_feedback"
                          hx-swap="innerHTML"
                          hx-encoding="multipart/form-data"
                          hx-on:chatFileUploaded="document.getElementById('chat_file_input').value='';"
                          hx-on:htmx:after-request="if(event.detail.successful){document.getElementById('chat_file_input').value='';}">
                        {% csrf_token %}

                        <input id="chat_file_input" name="file" type="file" accept="image/*,video/*"
                               class="block w-full text-sm text-gray-300 file:mr-3 file:py-2 file:px-3 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-gray-800 file:text-white hover:file:bg-gray-700"
                               {% if uploads_remaining == 0 %}disabled{% endif %} />

                        <button type="submit"
                                class="bg-gray-800 hover:bg-gray-700 text-white rounded-lg px-4 py-2 transition-colors text-sm"
                                {% if uploads_remaining == 0 %}disabled{% endif %}>
                            Upload{% if upload_limit %} ({{ uploads_used }}/{{ upload_limit }} used){% endif %}
                        </button>
                    </form>
                    <div id="upload_feedback" class="mt-2"></div>
                    {% if uploads_remaining == 0 %}
                        <div class="text-xs text-gray-400 mt-1">Upload limit reached for this room.</div>
                    {% endif %}
                </div>
            {% endif %}
        </div>
        </div>

    </div>
</wrapper>

<!-- Draggable call popup (WhatsApp-like) -->
<div id="call_popup" class="hidden fixed bottom-6 right-6 z-50 w-80 h-80 rounded-2xl border border-gray-800 bg-gray-900/95 shadow-2xl overflow-hidden">
    <div id="call_popup_header" class="px-3 py-2 bg-gray-900/90 border-b border-gray-800 flex items-center justify-between cursor-move select-none">
        <div class="min-w-0">
            <div id="call_popup_title" class="text-xs font-semibold text-gray-100 truncate">Call</div>
            <div id="call_popup_subtitle" class="text-[10px] text-gray-400 truncate">Connecting…</div>
        </div>
        <button id="call_popup_end" type="button" class="text-xs bg-gray-800 hover:bg-gray-700 text-white px-3 py-1.5 rounded-lg transition-colors">End</button>
    </div>
    <div class="p-3 h-[calc(100%-44px)]">
        <div id="call_popup_status" class="text-[11px] text-gray-400"></div>
        <div id="call_popup_video" class="hidden mt-3 grid grid-cols-2 gap-2 h-[calc(100%-26px)]">
            <div class="rounded-xl border border-gray-800 bg-black/30 overflow-hidden">
                <div id="call_local_player" class="w-full h-full"></div>
            </div>
            <div class="rounded-xl border border-gray-800 bg-black/30 overflow-hidden">
                <div id="call_remote_player" class="w-full h-full"></div>
            </div>
        </div>
    </div>
</div>

<script src="https://download.agora.io/sdk/release/AgoraRTC_N.js"></script>
<script>
    (function () {
        const chatroomName = "{{ chatroom_name|escapejs }}";
        const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsUrl = `${wsScheme}://${window.location.host}/ws/chatroom/${chatroomName}`;
        const pollUrl = "{% url 'chat-poll' chatroom_name %}";
        const inviteUrl = "{% url 'chat-call-invite' chatroom_name %}";
        const tokenUrl = "{% url 'agora-token' chatroom_name %}";
        const presenceUrl = "{% url 'chat-call-presence' chatroom_name %}";
        const otherUsername = "{% if other_user %}{{ other_user.username|escapejs }}{% else %}{% endif %}";
        const callEventUrl = "{% url 'chat-call-event' chatroom_name %}";
        const messageEditUrlTemplate = "{% url 'message-edit' 0 %}";
        const messageDeleteUrlTemplate = "{% url 'message-delete' 0 %}";

            // -------- Ringtone (incoming) --------
            let audioCtx = null;
            let ringTimer = null;
            let audioUnlocked = false;

            function unlockAudioOnce() {
                if (audioUnlocked) return;
                try {
                    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
                    // create a tiny silent buffer to unlock
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    g.gain.value = 0.00001;
                    o.connect(g);
                    g.connect(audioCtx.destination);
                    o.start();
                    o.stop(audioCtx.currentTime + 0.01);
                    audioUnlocked = true;
                } catch {
                    // ignore
                }
            }

            document.addEventListener('click', unlockAudioOnce, { once: true, capture: true });

            function stopIncomingRing() {
                if (ringTimer) {
                    clearInterval(ringTimer);
                    ringTimer = null;
                }
            }

            function playIncomingRing() {
                // Browsers may block until user interacts; we try best-effort.
                try {
                    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
                    if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});
                } catch {
                    return;
                }

                stopIncomingRing();

                const ringOnce = () => {
                    try {
                        const ctx = audioCtx;
                        const now = ctx.currentTime;
                        const g = ctx.createGain();
                        g.gain.setValueAtTime(0.0001, now);
                        g.gain.exponentialRampToValueAtTime(0.15, now + 0.02);
                        g.gain.exponentialRampToValueAtTime(0.0001, now + 1.8);
                        g.connect(ctx.destination);

                        const o1 = ctx.createOscillator();
                        const o2 = ctx.createOscillator();
                        o1.type = 'sine';
                        o2.type = 'sine';
                        o1.frequency.setValueAtTime(480, now);
                        o2.frequency.setValueAtTime(620, now);
                        o1.connect(g);
                        o2.connect(g);
                        o1.start(now);
                        o2.start(now);
                        o1.stop(now + 1.9);
                        o2.stop(now + 1.9);
                    } catch {
                        // ignore
                    }
                };

                // Classic ring cadence: ring ~2s, pause ~3s
                ringOnce();
                ringTimer = setInterval(ringOnce, 5000);
            }

        const form = document.getElementById('chat_message_form');
        const input = document.getElementById('id_body');
        const messagesEl = document.getElementById('chat_messages');
        const onlineCountEl = document.getElementById('online-count');

        const replyBar = document.getElementById('reply_bar');
        const replyBarAuthor = document.getElementById('reply_bar_author');
        const replyBarPreview = document.getElementById('reply_bar_preview');
        const replyBarCancel = document.getElementById('reply_bar_cancel');
        const replyToIdInput = document.getElementById('reply_to_id');

        const editBar = document.getElementById('edit_bar');
        const editBarPreview = document.getElementById('edit_bar_preview');
        const editBarCancel = document.getElementById('edit_bar_cancel');
        let editingMessageId = null;

        function startEditingMessage(messageId, body) {
            if (!input) return;
            editingMessageId = messageId;
            if (replyToIdInput) replyToIdInput.value = '';
            if (replyBar) replyBar.classList.add('hidden');

            if (editBarPreview) editBarPreview.textContent = (body || '').slice(0, 120);
            if (editBar) editBar.classList.remove('hidden');

            input.value = body || '';
            input.focus();
        }

        function cancelEditingMessage() {
            editingMessageId = null;
            if (editBar) editBar.classList.add('hidden');
            if (editBarPreview) editBarPreview.textContent = '';
        }

        if (editBarCancel) {
            editBarCancel.addEventListener('click', function () {
                cancelEditingMessage();
            });
        }

        const typingIndicatorEl = document.getElementById('typing_indicator');
        const typingIndicatorTextEl = document.getElementById('typing_indicator_text');
        const typingUsers = new Map();
        const typingTimers = new Map();
        let typingStopTimer = null;
        let lastTypingPingAt = 0;

        function renderTypingIndicator() {
            if (!typingIndicatorEl || !typingIndicatorTextEl) return;
            const names = Array.from(typingUsers.values()).filter(Boolean);
            if (!names.length) {
                typingIndicatorEl.classList.add('hidden');
                typingIndicatorTextEl.textContent = '';
                return;
            }
            typingIndicatorEl.classList.remove('hidden');
            typingIndicatorTextEl.textContent = `${names.join(', ')} typing...`;
        }

        function handleTypingEvent(payload) {
            const authorId = payload.author_id;
            if (!authorId) return;

            const username = (payload.username || '').trim();
            const isTyping = !!payload.is_typing;

            if (typingTimers.has(authorId)) {
                clearTimeout(typingTimers.get(authorId));
                typingTimers.delete(authorId);
            }

            if (isTyping) {
                typingUsers.set(authorId, username);
                typingTimers.set(authorId, setTimeout(() => {
                    typingUsers.delete(authorId);
                    typingTimers.delete(authorId);
                    renderTypingIndicator();
                }, 4000));
            } else {
                typingUsers.delete(authorId);
            }

            renderTypingIndicator();
        }

        function sendTyping(isTyping) {
            try {
                if (!socket || socket.readyState !== WebSocket.OPEN) return;
                socket.send(JSON.stringify({ type: 'typing', is_typing: !!isTyping }));
            } catch {
                // ignore
            }
        }

        if (input) {
            input.addEventListener('input', () => {
                const now = Date.now();
                if (now - lastTypingPingAt > 1200) {
                    sendTyping(true);
                    lastTypingPingAt = now;
                }
                if (typingStopTimer) clearTimeout(typingStopTimer);
                typingStopTimer = setTimeout(() => {
                    sendTyping(false);
                    typingStopTimer = null;
                }, 1800);
            });

            input.addEventListener('blur', () => {
                if (typingStopTimer) clearTimeout(typingStopTimer);
                typingStopTimer = null;
                sendTyping(false);
            });
        }

        if (form) {
            // Capture submit before HTMX when editing.
            form.addEventListener('submit', async (e) => {
                if (!editingMessageId) return;
                e.preventDefault();
                e.stopPropagation();

                const body = (input && input.value ? input.value : '').trim();
                if (!body) return;

                const url = messageEditUrlTemplate.replace('/0/', `/${editingMessageId}/`);
                try {
                    const params = new URLSearchParams();
                    params.set('body', body);
                    await fetch(url, {
                        method: 'POST',
                        credentials: 'same-origin',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-CSRFToken': (typeof getCookie === 'function' ? getCookie('csrftoken') : ''),
                        },
                        body: params,
                    });
                } catch {
                    // ignore
                }

                cancelEditingMessage();
                if (input) input.value = '';
                safeScrollToBottom();
            }, true);

            form.addEventListener('submit', () => {
                if (typingStopTimer) clearTimeout(typingStopTimer);
                typingStopTimer = null;
                sendTyping(false);
            });
        }

        let socket = null;
        let wsConnected = false;
        let lastId = 0;

        function hydrateLocalTimes(root) {
            const container = root || document;
            const nodes = container.querySelectorAll ? container.querySelectorAll('time[data-dt]') : [];
            if (!nodes || !nodes.length) return;

            const timeFmt = new Intl.DateTimeFormat(undefined, {
                hour: '2-digit',
                minute: '2-digit',
            });
            const fullFmt = new Intl.DateTimeFormat(undefined, {
                dateStyle: 'medium',
                timeStyle: 'short',
            });

            nodes.forEach((el) => {
                const iso = el.getAttribute('data-dt');
                if (!iso) return;
                const d = new Date(iso);
                if (Number.isNaN(d.getTime())) return;

                el.textContent = timeFmt.format(d);
                // Hover tooltip for clarity across dates/timezones
                el.setAttribute('title', fullFmt.format(d));
                if (!el.getAttribute('datetime')) el.setAttribute('datetime', iso);
            });
        }

        function safeScrollToBottom() {
            if (typeof scrollToBottom === 'function') scrollToBottom();
        }

        function updateLastIdFromDom() {
            const last = messagesEl && messagesEl.lastElementChild;
            const id = last && last.dataset ? parseInt(last.dataset.messageId || '0', 10) : 0;
            if (!Number.isNaN(id) && id > lastId) lastId = id;
        }

        function connect() {
            socket = new WebSocket(wsUrl);

            socket.onopen = function () {
                wsConnected = true;
                scrollToBottom();
            };

            socket.onmessage = function (event) {
                let payload;
                try {
                    payload = JSON.parse(event.data);
                } catch {
                    // Ignore unexpected non-JSON frames
                    return;
                }

                if (payload.type === 'chat_message' && payload.html) {
                    messagesEl.insertAdjacentHTML('beforeend', payload.html);
                    hydrateLocalTimes(messagesEl);
                    updateLastIdFromDom();
                    safeScrollToBottom();
                    return;
                }

                if (payload.type === 'typing') {
                    handleTypingEvent(payload);
                    return;
                }

                if (payload.type === 'message_update' && payload.message_id && payload.html) {
                    const el = document.getElementById(`msg-${payload.message_id}`);
                    if (el) {
                        el.outerHTML = payload.html;
                        hydrateLocalTimes(document);
                    }
                    return;
                }

                if (payload.type === 'message_delete' && payload.message_id) {
                    const el = document.getElementById(`msg-${payload.message_id}`);
                    if (el) el.remove();
                    return;
                }

                if (payload.type === 'online_count' && typeof payload.online_count !== 'undefined') {
                    if (onlineCountEl) onlineCountEl.textContent = payload.online_count;
                }

                if (payload.type === 'call_invite') {
                    if (!window.__hasGlobalCallInvite) {
                        showIncomingCall(payload);
                    }
                }

                if (payload.type === 'call_control') {
                    if (payload.action === 'end' || payload.action === 'decline') {
                        endCallPopup(payload.action === 'decline' ? 'Call declined' : 'Call ended');
                    }
                }
            };

            socket.onclose = function () {
                wsConnected = false;
                // Simple reconnect
                setTimeout(connect, 1000);
            };

            socket.onerror = function () {
                wsConnected = false;
            };
        }

        // Ensure correct position on initial render
        document.addEventListener('DOMContentLoaded', function () {
            updateLastIdFromDom();
            hydrateLocalTimes(document);
            safeScrollToBottom();
        });

        // -------- Message Edit/Delete (hover actions) --------
        document.addEventListener('click', async function (e) {
            const editBtn = e.target.closest('[data-edit-message]');
            const delBtn = e.target.closest('[data-delete-message]');

            if (!editBtn && !delBtn) return;
            e.preventDefault();
            e.stopPropagation();

            const messageId = (editBtn || delBtn).dataset.messageId;
            if (!messageId) return;

            if (editBtn) {
                const body = editBtn.dataset.messageBody || '';
                startEditingMessage(messageId, body);
                return;
            }

            if (delBtn) {
                const url = messageDeleteUrlTemplate.replace('/0/', `/${messageId}/`);
                try {
                    await fetch(url, {
                        method: 'POST',
                        credentials: 'same-origin',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-CSRFToken': (typeof getCookie === 'function' ? getCookie('csrftoken') : ''),
                        },
                        body: new URLSearchParams(),
                    });
                } catch {
                    // ignore
                }
            }
        });

        function ensureIncomingContainer() {
            let c = document.getElementById('incoming-call-container');
            if (c) return c;
            c = document.createElement('div');
            c.id = 'incoming-call-container';
            c.className = 'fixed top-24 right-6 z-50 w-[min(24rem,calc(100vw-3rem))] space-y-3';
            document.body.appendChild(c);
            return c;
        }

        function showIncomingCall(payload) {
            const container = ensureIncomingContainer();
            const from = payload.from_username || 'Someone';
            const type = (payload.call_type || 'voice').toLowerCase() === 'video' ? 'video' : 'voice';

            playIncomingRing();

            const toast = document.createElement('div');
            toast.className = 'pointer-events-auto flex items-start gap-3 rounded-xl border border-gray-800 bg-gray-900/90 px-4 py-3 text-sm text-gray-100 shadow-lg shadow-black/20';
            toast.innerHTML = `
                <div class="mt-0.5 h-2.5 w-2.5 flex-none rounded-full bg-emerald-400"></div>
                <div class="flex-1">
                    <div class="font-semibold">Incoming ${type === 'video' ? 'video' : 'voice'} call</div>
                    <div class="text-gray-300 text-xs mt-0.5">from ${from}</div>
                    <div class="mt-3 flex gap-2">
                        <button type="button" data-accept class="text-xs bg-emerald-500 hover:bg-emerald-600 text-white px-3 py-1.5 rounded-lg transition-colors">Accept</button>
                        <button type="button" data-decline class="text-xs bg-gray-800 hover:bg-gray-700 text-white px-3 py-1.5 rounded-lg transition-colors">Decline</button>
                    </div>
                </div>
                <button type="button" data-close class="-mr-1 -mt-1 inline-flex h-8 w-8 items-center justify-center rounded-lg text-gray-300 hover:text-white hover:bg-gray-800/60 transition" aria-label="Dismiss">
                    <span aria-hidden="true">×</span>
                </button>
            `;

            const removeToast = () => {
                toast.classList.add('opacity-0');
                setTimeout(() => toast.remove(), 200);
                stopIncomingRing();
            };
            toast.querySelector('[data-close]')?.addEventListener('click', removeToast);
            toast.querySelector('[data-accept]')?.addEventListener('click', async () => {
                stopIncomingRing();
                window.__hasGlobalCallInvite = true;
                removeToast();
                await openCallPopup(type, 'callee');
            });
            toast.querySelector('[data-decline]')?.addEventListener('click', async () => {
                try {
                    const body = new URLSearchParams();
                    body.set('action', 'decline');
                    body.set('type', type);
                    await fetch(callEventUrl, {
                        method: 'POST',
                        credentials: 'same-origin',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-CSRFToken': (typeof getCookie === 'function' ? getCookie('csrftoken') : ''),
                        },
                        body,
                    });
                } catch {
                    // ignore
                }
                removeToast();
            });
            setTimeout(removeToast, 15000);

            container.appendChild(toast);
        }

        // --- Call popup (no separate page) ---
        const callPopupEl = document.getElementById('call_popup');
        const callPopupHeaderEl = document.getElementById('call_popup_header');
        const callPopupTitleEl = document.getElementById('call_popup_title');
        const callPopupSubtitleEl = document.getElementById('call_popup_subtitle');
        const callPopupStatusEl = document.getElementById('call_popup_status');
        const callPopupVideoEl = document.getElementById('call_popup_video');
        const callLocalEl = document.getElementById('call_local_player');
        const callRemoteEl = document.getElementById('call_remote_player');
        const callEndBtn = document.getElementById('call_popup_end');

        let callActive = false;
        let callTypeActive = null;
        let callRoleActive = null;
        let callClient = null;
        let localTracks = { audio: null, video: null };

        function setCallStatus(text) {
            if (callPopupStatusEl) callPopupStatusEl.textContent = text || '';
            if (callPopupSubtitleEl) callPopupSubtitleEl.textContent = text || '';
        }

        function showCallPopup() {
            if (!callPopupEl) return;
            callPopupEl.classList.remove('hidden');
        }

        function hideCallPopup() {
            if (!callPopupEl) return;
            callPopupEl.classList.add('hidden');
        }

        async function fetchAgoraToken() {
            const res = await fetch(tokenUrl, { credentials: 'same-origin' });
            const data = await res.json();
            if (!res.ok || data.error) throw new Error(data.error || 'Token fetch failed');
            return data;
        }

        function getCsrf() {
            try { return (typeof getCookie === 'function' ? getCookie('csrftoken') : ''); } catch { return ''; }
        }

        async function announcePresence(action, uid, type) {
            try {
                const body = new URLSearchParams();
                body.set('action', action);
                body.set('type', type);
                body.set('uid', String(uid || 0));
                await fetch(presenceUrl, {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': getCsrf(),
                    },
                    body,
                });
            } catch {
                // ignore
            }
        }

        async function postCallEvent(action, type) {
            try {
                const body = new URLSearchParams();
                body.set('action', action);
                body.set('type', type);
                await fetch(callEventUrl, {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': getCsrf(),
                    },
                    body,
                });
            } catch {
                // ignore
            }
        }

        async function openCallPopup(type, role) {
            if (callActive) return;
            callActive = true;
            callTypeActive = (type || 'voice');
            callRoleActive = (role || 'caller');

            showCallPopup();
            if (callPopupTitleEl) callPopupTitleEl.textContent = callTypeActive === 'video' ? 'Video call' : 'Voice call';
            setCallStatus('Connecting…');

            if (callPopupVideoEl) {
                if (callTypeActive === 'video') callPopupVideoEl.classList.remove('hidden');
                else callPopupVideoEl.classList.add('hidden');
            }

            try {
                const { token, uid, channel, app_id } = await fetchAgoraToken();
                if (!app_id) throw new Error('Agora is not configured (missing AGORA_APP_ID).');

                callClient = AgoraRTC.createClient({ mode: 'rtc', codec: 'vp8' });

                callClient.on('user-joined', (user) => {
                    if (callPopupSubtitleEl) {
                        callPopupSubtitleEl.textContent = otherUsername ? `${otherUsername} joined` : 'User joined';
                    }
                });

                callClient.on('user-published', async (user, mediaType) => {
                    await callClient.subscribe(user, mediaType);
                    if (mediaType === 'video' && callRemoteEl) {
                        try { user.videoTrack.play(callRemoteEl); } catch {}
                    }
                    if (mediaType === 'audio') {
                        try { user.audioTrack.play(); } catch {}
                    }
                    setCallStatus('In call');
                });

                callClient.on('user-left', () => {
                    setCallStatus('Waiting…');
                });

                await callClient.join(app_id, channel, token, uid);
                await announcePresence('join', uid, callTypeActive);

                if (callRoleActive === 'caller') {
                    await postCallEvent('start', callTypeActive);
                }

                localTracks.audio = await AgoraRTC.createMicrophoneAudioTrack({ AEC: true, AGC: true, ANS: true });
                if (callTypeActive === 'video') {
                    localTracks.video = await AgoraRTC.createCameraVideoTrack();
                    if (callLocalEl) {
                        try { localTracks.video.play(callLocalEl); } catch {}
                    }
                    await callClient.publish([localTracks.audio, localTracks.video]);
                } else {
                    await callClient.publish([localTracks.audio]);
                }

                setCallStatus('In call');
            } catch (e) {
                setCallStatus('Error: ' + (e && e.message ? e.message : String(e)));
            }
        }

        async function endCallPopup(reason) {
            if (!callActive) return;
            try {
                if (reason) setCallStatus(reason);
                // Broadcast end marker (only once is fine; server dedupes)
                if (callTypeActive) await postCallEvent('end', callTypeActive);
            } catch {}

            try {
                if (localTracks.video) {
                    try { localTracks.video.stop(); } catch {}
                    try { localTracks.video.close(); } catch {}
                }
                if (localTracks.audio) {
                    try { localTracks.audio.stop(); } catch {}
                    try { localTracks.audio.close(); } catch {}
                }
            } catch {}

            try {
                if (callClient) {
                    try { await callClient.leave(); } catch {}
                }
            } catch {}

            callClient = null;
            localTracks = { audio: null, video: null };
            callActive = false;
            callTypeActive = null;
            callRoleActive = null;
            hideCallPopup();
        }

        if (callEndBtn) {
            callEndBtn.addEventListener('click', () => endCallPopup('Call ended'));
        }

        // Draggable popup
        (function () {
            if (!callPopupEl || !callPopupHeaderEl) return;
            let dragging = false;
            let offsetX = 0;
            let offsetY = 0;

            callPopupHeaderEl.addEventListener('pointerdown', (e) => {
                dragging = true;
                callPopupEl.setPointerCapture(e.pointerId);
                const rect = callPopupEl.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
            });

            callPopupHeaderEl.addEventListener('pointermove', (e) => {
                if (!dragging) return;
                const left = Math.max(8, Math.min(window.innerWidth - callPopupEl.offsetWidth - 8, e.clientX - offsetX));
                const top = Math.max(8, Math.min(window.innerHeight - callPopupEl.offsetHeight - 8, e.clientY - offsetY));
                callPopupEl.style.left = `${left}px`;
                callPopupEl.style.top = `${top}px`;
                callPopupEl.style.right = 'auto';
                callPopupEl.style.bottom = 'auto';
            });

            callPopupHeaderEl.addEventListener('pointerup', (e) => {
                dragging = false;
                try { callPopupEl.releasePointerCapture(e.pointerId); } catch {}
            });

            callPopupHeaderEl.addEventListener('pointercancel', (e) => {
                dragging = false;
                try { callPopupEl.releasePointerCapture(e.pointerId); } catch {}
            });
        })();

        // When clicking call buttons, notify the other member first, then open popup.
        document.addEventListener('click', async function (e) {
            const a = e.target && e.target.closest ? e.target.closest('[data-call-btn]') : null;
            if (!a) return;
            e.preventDefault();

            const type = a.getAttribute('data-call-type') || 'voice';
            try {
                const body = new URLSearchParams();
                body.set('type', type);
                await fetch(inviteUrl, {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': (typeof getCookie === 'function' ? getCookie('csrftoken') : ''),
                    },
                    body,
                });
            } catch {
                // ignore
            }
            await openCallPopup(type, 'caller');
        }, true);

        async function poll() {
            // Fallback: if websocket isn't connected, poll for new messages
            if (wsConnected) return;
            try {
                updateLastIdFromDom();
                const res = await fetch(`${pollUrl}?after=${lastId}`, { credentials: 'same-origin' });
                if (!res.ok) return;
                const data = await res.json();
                if (data && typeof data.online_count !== 'undefined') {
                    if (onlineCountEl) onlineCountEl.textContent = data.online_count;
                }
                if (data && data.messages_html) {
                    messagesEl.insertAdjacentHTML('beforeend', data.messages_html);
                    hydrateLocalTimes(messagesEl);
                    updateLastIdFromDom();
                    safeScrollToBottom();
                }
                if (data && typeof data.last_id !== 'undefined') {
                    const newLast = parseInt(String(data.last_id), 10);
                    if (!Number.isNaN(newLast) && newLast > lastId) lastId = newLast;
                }
            } catch {
                // ignore
            }
        }

        setInterval(poll, 1200);
        connect();

        function clearReply() {
            if (replyToIdInput) replyToIdInput.value = '';
            if (replyBar) replyBar.classList.add('hidden');
            if (replyBarAuthor) replyBarAuthor.textContent = '';
            if (replyBarPreview) replyBarPreview.textContent = '';
        }

        if (replyBarCancel) {
            replyBarCancel.addEventListener('click', function () {
                clearReply();
                if (input) input.focus();
            });
        }

        // Click "Reply" on a message bubble
        document.addEventListener('click', function (e) {
            const btn = e.target && e.target.closest ? e.target.closest('[data-reply-button]') : null;
            if (!btn) return;

            const msgId = btn.getAttribute('data-reply-to-id') || '';
            const author = btn.getAttribute('data-reply-author') || '';
            const preview = btn.getAttribute('data-reply-preview') || '';

            if (replyToIdInput) replyToIdInput.value = msgId;
            if (replyBarAuthor) replyBarAuthor.textContent = author;
            if (replyBarPreview) replyBarPreview.textContent = preview;
            if (replyBar) replyBar.classList.remove('hidden');
            if (input) input.focus();
        }, true);

        // Click replied-to snippet to jump to original
        document.addEventListener('click', function (e) {
            const jump = e.target && e.target.closest ? e.target.closest('[data-scroll-to]') : null;
            if (!jump) return;
            const targetId = jump.getAttribute('data-scroll-to');
            if (!targetId) return;
            const el = document.getElementById(targetId);
            if (!el) return;
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, true);
    })();
</script>

<style>
    @keyframes fadeInAndUp {
        from { opacity: 0; transform: translateY(12px); }
        to { opacity: 1; transform: translateY(0px); }
    }
    .fade-in-up {
        animation: fadeInAndUp 0.35s ease;
    }

    /* Custom Scrollbar for Chat */
    #chat_container::-webkit-scrollbar { width: 6px; }
    #chat_container::-webkit-scrollbar-track { background: transparent; }
    #chat_container::-webkit-scrollbar-thumb { background: rgb(75 85 99); border-radius: 9999px; }
    #chat_container::-webkit-scrollbar-thumb:hover { background: rgb(16 185 129); }
</style>
{% endblock %}