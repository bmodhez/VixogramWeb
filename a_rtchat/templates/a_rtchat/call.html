{% extends 'base.html' %}
{% load static %}

{% block content %}
<div class="max-w-5xl mx-auto">
    <div class="bg-gray-900/60 border border-gray-800 rounded-2xl shadow-2xl overflow-hidden">
        <div class="flex items-center justify-between px-5 py-4 border-b border-gray-800">
            <div>
                <div class="text-sm text-gray-300">{% if call_type == 'video' %}Video call{% else %}Voice call{% endif %}</div>
                <div class="text-xs text-gray-500">Room: {{ chatroom_name }}</div>
            </div>
            <a id="call_end_back" href="{% url 'chatroom' chatroom_name %}" class="text-sm bg-gray-800 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-colors">
                End / Back
            </a>
        </div>

        <div class="p-5">
            <div class="flex items-start justify-between gap-4 mb-4">
                <div>
                    <div id="call-phase" class="text-sm text-gray-200">Calling…</div>
                    <div id="call-loading" class="mt-2 hidden items-center gap-2 text-xs text-gray-300">
                        <div class="w-4 h-4 rounded-full border-2 border-gray-600 border-t-emerald-500 animate-spin"></div>
                        <span id="call-loading-text">Loading…</span>
                    </div>
                    <div class="text-xs text-gray-500 mt-1">Participants: <span id="participants-count">1</span></div>
                </div>
                <div class="text-right">
                    <div class="text-xs text-gray-500">In call</div>
                    <div id="participants-names" class="text-xs text-gray-300 mt-1">You</div>
                    <div class="mt-2">
                        <div class="text-xs text-gray-500">Free time left</div>
                        <div id="free-limit-timer" class="text-xs text-gray-200 mt-1 tabular-nums">--:--</div>
                    </div>
                </div>
            </div>

            {% if call_type == 'video' %}
                <div class="rounded-xl border border-gray-800 bg-gray-950/40 p-3">
                    <div class="text-xs text-gray-400 mb-2">Participants</div>
                    <div id="video-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3"></div>
                </div>
            {% else %}
                <div class="rounded-xl border border-gray-800 bg-gray-950/40 p-3">
                    <div class="text-xs text-gray-400 mb-2">Participants</div>
                    <div id="voice-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3"></div>
                </div>
            {% endif %}

            <div id="call-status" class="mt-4 text-xs text-gray-400"></div>
        </div>
    </div>
</div>

<div id="free-limit-popup" class="fixed inset-0 hidden items-center justify-center bg-black/60 z-50">
    <div class="w-full max-w-sm mx-4 rounded-2xl border border-gray-800 bg-gray-900 p-5">
        <div class="text-sm text-gray-100 font-semibold">Free limit reached</div>
        <div class="text-xs text-gray-400 mt-1">Your call will end now.</div>
    </div>
</div>

<script src="https://download.agora.io/sdk/release/AgoraRTC_N.js"></script>
<script id="vixo-call-config" type="application/json">
{
    "callType": "{{ call_type|escapejs }}",
    "channel": "{{ chatroom_name|escapejs }}",
    "callRole": "{{ call_role|escapejs }}",
    "currentUsername": "{{ user.username|escapejs }}",
    "tokenUrl": "{% url 'agora-token' chatroom_name %}",
    "presenceUrl": "{% url 'chat-call-presence' chatroom_name %}",
    "callEventUrl": "{% url 'chat-call-event' chatroom_name %}",
    "backUrl": "{% url 'chatroom' chatroom_name %}",
    "memberUsernames": {{ member_usernames|safe }}
}
</script>

<script src="{% static 'js/call.js' %}" defer></script>

{% comment %}
<script>
(function () {
    const callType = "{{ call_type|escapejs }}";
    const channel = "{{ chatroom_name|escapejs }}";
    const callRole = "{{ call_role|escapejs }}";
    const currentUsername = "{{ user.username|escapejs }}";
    const tokenUrl = "{% url 'agora-token' chatroom_name %}";
    const presenceUrl = "{% url 'chat-call-presence' chatroom_name %}";
    const callEventUrl = "{% url 'chat-call-event' chatroom_name %}";
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${wsScheme}://${window.location.host}/ws/chatroom/${channel}`;
    const memberUsernames = {{ member_usernames|safe }};

    const phaseEl = document.getElementById('call-phase');
    const countEl = document.getElementById('participants-count');
    const namesEl = document.getElementById('participants-names');
    const freeLimitTimerEl = document.getElementById('free-limit-timer');
    const freeLimitPopupEl = document.getElementById('free-limit-popup');
    const loadingEl = document.getElementById('call-loading');
    const loadingTextEl = document.getElementById('call-loading-text');

    const statusEl = document.getElementById('call-status');
    const setStatus = (t) => { if (statusEl) statusEl.textContent = t; };
    const setPhase = (t) => { if (phaseEl) phaseEl.textContent = t; };

    function showLoading(text) {
        if (!loadingEl) return;
        if (loadingTextEl) loadingTextEl.textContent = text || 'Loading…';
        loadingEl.classList.remove('hidden');
        loadingEl.classList.add('flex');
    }

    function hideLoading() {
        if (!loadingEl) return;
        loadingEl.classList.add('hidden');
        loadingEl.classList.remove('flex');
    }

    // --- Free call limit ---
    // Voice: 4 min, Video: 2 min
    const FREE_LIMIT_SECONDS = (callType === 'video') ? 2 * 60 : 4 * 60;
    let freeLimitDeadlineMs = null;
    let freeLimitInterval = null;
    let freeLimitStarted = false;

    function formatMMSS(totalSeconds) {
        const s = Math.max(0, Number(totalSeconds || 0));
        const mm = String(Math.floor(s / 60)).padStart(2, '0');
        const ss = String(Math.floor(s % 60)).padStart(2, '0');
        return `${mm}:${ss}`;
    }

    function setFreeLimitTimer(secondsLeft) {
        if (!freeLimitTimerEl) return;
        freeLimitTimerEl.textContent = formatMMSS(secondsLeft);
    }

    function showFreeLimitPopup() {
        if (!freeLimitPopupEl) return;
        freeLimitPopupEl.classList.remove('hidden');
        freeLimitPopupEl.classList.add('flex');
    }

    function stopFreeLimitCountdown() {
        if (freeLimitInterval) {
            clearInterval(freeLimitInterval);
            freeLimitInterval = null;
        }
    }

    function startFreeLimitCountdown() {
        if (freeLimitStarted) return;
        freeLimitStarted = true;

        freeLimitDeadlineMs = Date.now() + (FREE_LIMIT_SECONDS * 1000);
        setFreeLimitTimer(FREE_LIMIT_SECONDS);

        freeLimitInterval = setInterval(() => {
            const remainingMs = Math.max(0, freeLimitDeadlineMs - Date.now());
            const remainingSeconds = Math.ceil(remainingMs / 1000);
            setFreeLimitTimer(remainingSeconds);
            if (remainingSeconds <= 0) {
                stopFreeLimitCountdown();
                // End immediately; keep popup visible briefly before redirect.
                showFreeLimitPopup();
                hangupAndExit('Free limit reached', { redirectDelayMs: 1200, sendEndEvent: true });
            }
        }, 250);
    }

    // Set initial display so user always sees the limit.
    setFreeLimitTimer(FREE_LIMIT_SECONDS);

    const client = AgoraRTC.createClient({ mode: 'rtc', codec: 'vp8' });

    let localTracks = { audio: null, video: null };

    // Remote audio can be blocked by autoplay policies; keep references to retry on user gesture.
    const remoteAudioTracks = new Map(); // uid -> audioTrack
    let audioPlaybackBlocked = false;

    function tryPlayAllRemoteAudio() {
        let playedAny = false;
        for (const track of remoteAudioTracks.values()) {
            if (!track) continue;
            try {
                track.play();
                playedAny = true;
            } catch {
                // still blocked
            }
        }
        if (playedAny) {
            audioPlaybackBlocked = false;
            setStatus('Connected (audio playing)');
        }
    }

    // uid -> username (UI only)
    const participants = new Map();
    participants.set('me', 'You');

    // Remote video containers (uid -> { cardEl, playerEl, labelEl })
    const remoteCards = new Map();
    // Voice participant cards (uid -> { cardEl, labelEl })
    const voiceCards = new Map();

    function getVideoGrid() {
        return document.getElementById('video-grid');
    }

    function getVoiceGrid() {
        return document.getElementById('voice-grid');
    }

    function ensureLocalTile() {
        if (callType === 'video') {
            const grid = getVideoGrid();
            if (!grid) return;
            if (document.getElementById('local-player')) return;

            const card = document.createElement('div');
            card.className = 'rounded-lg border border-gray-800 bg-black/20 p-2';

            const label = document.createElement('div');
            label.className = 'text-[11px] text-gray-400 mb-2 truncate';
            label.textContent = 'You';

            const player = document.createElement('div');
            player.id = 'local-player';
            player.className = 'w-full aspect-video bg-black/40 rounded-md overflow-hidden';

            card.appendChild(label);
            card.appendChild(player);
            grid.appendChild(card);
        } else {
            const grid = getVoiceGrid();
            if (!grid) return;
            if (document.getElementById('local-voice-tile')) return;

            const card = document.createElement('div');
            card.id = 'local-voice-tile';
            card.className = 'rounded-lg border border-gray-800 bg-black/20 p-3 flex items-center justify-between gap-3';

            const left = document.createElement('div');
            const label = document.createElement('div');
            label.className = 'text-sm text-gray-200 truncate';
            label.textContent = 'You';
            const sub = document.createElement('div');
            sub.className = 'text-[11px] text-gray-500 mt-0.5';
            sub.textContent = 'Voice connected';
            left.appendChild(label);
            left.appendChild(sub);

            const badge = document.createElement('div');
            badge.className = 'text-[11px] px-2 py-1 rounded-md border border-gray-800 bg-gray-950/40 text-gray-300';
            badge.textContent = 'Mic';

            card.appendChild(left);
            card.appendChild(badge);
            grid.appendChild(card);
        }
    }

    function removeRemoteCard(uid) {
        const key = String(uid);
        const entry = remoteCards.get(key);
        if (!entry) return;
        try { entry.playerEl.innerHTML = ''; } catch {}
        try { entry.cardEl.remove(); } catch {}
        remoteCards.delete(key);
    }

    function removeVoiceCard(uid) {
        const key = String(uid);
        const entry = voiceCards.get(key);
        if (!entry) return;
        try { entry.cardEl.remove(); } catch {}
        voiceCards.delete(key);
    }

    function setRemotePlaceholder(uid, text) {
        const key = String(uid);
        const entry = remoteCards.get(key);
        if (!entry) return;
        entry.playerEl.innerHTML = '';
        const msg = document.createElement('div');
        msg.className = 'w-full h-full flex items-center justify-center text-xs text-gray-400';
        msg.textContent = text;
        entry.playerEl.appendChild(msg);
    }

    function ensureRemoteCard(uid) {
        const grid = getVideoGrid();
        if (!grid || !uid) return null;
        const key = String(uid);
        const existing = remoteCards.get(key);
        if (existing) return existing;

        const card = document.createElement('div');
        card.className = 'rounded-lg border border-gray-800 bg-black/20 p-2';

        const label = document.createElement('div');
        label.className = 'text-[11px] text-gray-400 mb-2 truncate';
        label.textContent = participants.get(key) || `User ${key}`;

        const player = document.createElement('div');
        player.id = `remote-player-${key}`;
        player.className = 'w-full aspect-video bg-black/40 rounded-md overflow-hidden';

        card.appendChild(label);
        card.appendChild(player);
        grid.appendChild(card);

        const entry = { cardEl: card, playerEl: player, labelEl: label };
        remoteCards.set(key, entry);
        setRemotePlaceholder(uid, 'Waiting for video…');
        return entry;
    }

    function ensureVoiceCard(uid) {
        const grid = getVoiceGrid();
        if (!grid || !uid) return null;
        const key = String(uid);
        const existing = voiceCards.get(key);
        if (existing) return existing;

        const card = document.createElement('div');
        card.className = 'rounded-lg border border-gray-800 bg-black/20 p-3 flex items-center justify-between gap-3';

        const left = document.createElement('div');
        const label = document.createElement('div');
        label.className = 'text-sm text-gray-200 truncate';
        label.textContent = participants.get(key) || `User ${key}`;
        const sub = document.createElement('div');
        sub.className = 'text-[11px] text-gray-500 mt-0.5';
        sub.textContent = 'In voice call';
        left.appendChild(label);
        left.appendChild(sub);

        const badge = document.createElement('div');
        badge.className = 'text-[11px] px-2 py-1 rounded-md border border-gray-800 bg-gray-950/40 text-gray-300';
        badge.textContent = 'Mic';

        card.appendChild(left);
        card.appendChild(badge);
        grid.appendChild(card);

        const entry = { cardEl: card, labelEl: label };
        voiceCards.set(key, entry);
        return entry;
    }

    const otherUsername = (Array.isArray(memberUsernames) && memberUsernames.length === 2)
        ? (memberUsernames.find((u) => u && u !== currentUsername) || '')
        : '';

    function ensureRemoteParticipant(uid) {
        if (!uid) return;
        const key = String(uid);
        if (participants.has(key)) return;
        // If presence WS missed earlier join events, Agora events still confirm remote presence.
        // For 1:1 rooms we can reliably map to the "other" username.
        participants.set(key, otherUsername || `User ${key}`);
        renderParticipants();
        // Ensure there's a UI tile for this participant.
        if (callType === 'video') {
            ensureRemoteCard(uid);
        } else {
            ensureVoiceCard(uid);
        }
    }

    function renderParticipants() {
        const names = Array.from(participants.values()).filter(Boolean);
        const unique = Array.from(new Set(names));
        const others = unique.filter((n) => n !== 'You' && n !== currentUsername);

        // Count includes you + others (so it stays 1 when alone).
        if (countEl) countEl.textContent = String(Math.max(1, 1 + others.length));
        // Right-side "In call" list should show only other joined users.
        if (namesEl) namesEl.textContent = others.length ? others.join(', ') : 'Waiting…';

        // Update card labels (best-effort)
        for (const [uid, entry] of remoteCards.entries()) {
            try { entry.labelEl.textContent = participants.get(uid) || `User ${uid}`; } catch {}
        }

        for (const [uid, entry] of voiceCards.entries()) {
            try { entry.labelEl.textContent = participants.get(uid) || `User ${uid}`; } catch {}
        }
    }
    renderParticipants();

    // Render local tile immediately so layout is correct before media starts.
    ensureLocalTile();

    function getCsrf() {
        try { return (typeof getCookie === 'function' ? getCookie('csrftoken') : ''); } catch { return ''; }
    }

    async function postCallEvent(action) {
        try {
            const body = new URLSearchParams();
            body.set('action', action);
            body.set('type', callType);
            await fetch(callEventUrl, {
                method: 'POST',
                credentials: 'same-origin',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': getCsrf(),
                },
                body,
            });
        } catch {
            // ignore
        }
    }

    async function announcePresence(action, uid) {
        try {
            const body = new URLSearchParams();
            body.set('action', action);
            body.set('type', callType);
            body.set('uid', String(uid || 0));
            await fetch(presenceUrl, {
                method: 'POST',
                credentials: 'same-origin',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': getCsrf(),
                },
                body,
            });
        } catch {
            // ignore
        }
    }

    // Presence websocket: receive {username, uid} join/leave
    let presenceWs = null;
    let remoteEnded = false;
    let endSent = false;

    // -------- Ringtone (outgoing) --------
    let audioCtx = null;
    let ringTimer = null;
    let ringWanted = false;

    function ensureAudioContext() {
        try {
            audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        } catch {
            return null;
        }
    }

    function stopOutgoingRing() {
        ringWanted = false;
        if (ringTimer) {
            clearInterval(ringTimer);
            ringTimer = null;
        }
    }

    function playOutgoingRing() {
        // Only for caller while waiting
        if (callRole !== 'caller') return;
        ringWanted = true;

        const ctx = ensureAudioContext();
        if (!ctx) return;

        const ringOnce = () => {
            try {
                const ctx = audioCtx;
                const now = ctx.currentTime;
                const g = ctx.createGain();
                g.gain.setValueAtTime(0.0001, now);
                g.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
                g.gain.exponentialRampToValueAtTime(0.0001, now + 1.1);
                g.connect(ctx.destination);

                const o = ctx.createOscillator();
                o.type = 'sine';
                o.frequency.setValueAtTime(440, now);
                o.connect(g);
                o.start(now);
                o.stop(now + 1.2);
            } catch {
                // ignore
            }
        };

        const startLoop = () => {
            if (!ringWanted) return;
            if (ringTimer) return;
            ringOnce();
            ringTimer = setInterval(ringOnce, 2500);
        };

        if (ctx.state === 'suspended') {
            ctx.resume().then(startLoop).catch(() => {});
            return;
        }
        startLoop();
    }

    // Autoplay policies: if audio is blocked, retry on first user gesture.
    document.addEventListener('pointerdown', function () {
        if (!ringWanted) return;
        playOutgoingRing();
    }, { passive: true });

    // Retry remote audio on any user gesture (Chrome/Safari autoplay policy).
    document.addEventListener('pointerdown', function () {
        if (!audioPlaybackBlocked) return;
        tryPlayAllRemoteAudio();
    }, { passive: true });

    async function hangupAndExit(reason, opts) {
        const options = opts || {};
        if (remoteEnded) return;
        remoteEnded = true;
        endSent = true;
        stopOutgoingRing();
        stopFreeLimitCountdown();
        setPhase('Call ended');
        if (reason) setStatus(reason);

        if (options && options.sendEndEvent) {
            try { await postCallEvent('end'); } catch { /* ignore */ }
        }

        try {
            if (localTracks.video) {
                try { localTracks.video.stop(); } catch {}
                try { localTracks.video.close(); } catch {}
            }
            if (localTracks.audio) {
                try { localTracks.audio.stop(); } catch {}
                try { localTracks.audio.close(); } catch {}
            }
        } catch {}

        try { await client.leave(); } catch {}
        try { if (presenceWs) presenceWs.close(); } catch {}

        const redirect = () => { window.location.href = "{% url 'chatroom' chatroom_name %}"; };
        const delay = Number(options && options.redirectDelayMs ? options.redirectDelayMs : 0);
        if (delay > 0) {
            setTimeout(redirect, delay);
        } else {
            redirect();
        }
    }

    function connectPresenceWs() {
        try {
            presenceWs = new WebSocket(wsUrl);
            presenceWs.onmessage = (event) => {
                let payload;
                try { payload = JSON.parse(event.data); } catch { return; }

                if (payload.type === 'call_presence') {
                    const action = payload.action || 'join';
                    const uid = payload.uid;
                    const username = payload.username || '';
                    if (!uid || !username) return;

                    // Ignore our own presence echo so we don't show "You, <myname>".
                    if (username === currentUsername) return;

                    if (action === 'leave') {
                        participants.delete(String(uid));
                        if (callType === 'video') {
                            removeRemoteCard(uid);
                        } else {
                            removeVoiceCard(uid);
                        }
                    } else {
                        participants.set(String(uid), username);
                        ensureRemoteParticipant(uid);
                    }
                    renderParticipants();
                    // In-call only when at least one other participant is present.
                    if (participants.size > 1) {
                        setPhase('In call');
                        stopOutgoingRing();
                    }
                    return;
                }

                if (payload.type === 'call_control' && payload.action === 'end') {
                    const from = payload.from_username ? ` by ${payload.from_username}` : '';
                    hangupAndExit(`Call ended${from}`);
                }

                if (payload.type === 'call_control' && payload.action === 'decline') {
                    const from = payload.from_username ? ` by ${payload.from_username}` : '';
                    hangupAndExit(`Call declined${from}`);
                }
            };
        } catch {
            // ignore
        }
    }

    function ensureAppIdPresent(appId) {
        if (!appId) {
            setStatus('Agora is not configured (missing AGORA_APP_ID).');
            return false;
        }
        return true;
    }

    async function fetchToken() {
        const res = await fetch(tokenUrl, { credentials: 'same-origin' });
        const data = await res.json();
        if (!res.ok || data.error) throw new Error(data.error || 'Token fetch failed');
        return data;
    }

    async function join() {
        try {
            showLoading('Connecting…');
            connectPresenceWs();
            setPhase('Calling…');
            setStatus('Connecting…');
            showLoading('Fetching access…');
            const { token, uid, app_id } = await fetchToken();
            if (!ensureAppIdPresent(app_id)) return;

            showLoading('Joining call…');

            // Start outgoing ring once user is on the call page.
            playOutgoingRing();

            client.on('user-published', async (user, mediaType) => {
                try { ensureRemoteParticipant(user && user.uid); } catch { /* ignore */ }
                await client.subscribe(user, mediaType);
                if (mediaType === 'video') {
                    const card = ensureRemoteCard(user && user.uid);
                    if (card && user.videoTrack) {
                        try { card.playerEl.innerHTML = ''; } catch {}
                        user.videoTrack.play(card.playerEl);
                    }
                }
                if (mediaType === 'audio') {
                    try {
                        remoteAudioTracks.set(String(user.uid), user.audioTrack);
                        user.audioTrack.play();
                    } catch {
                        audioPlaybackBlocked = true;
                        setStatus('Sound is blocked by browser. Tap anywhere to enable audio.');
                    }
                }
            });

            client.on('user-unpublished', (user, mediaType) => {
                if (!user) return;
                if (mediaType === 'video') {
                    setRemotePlaceholder(user.uid, 'Video off');
                }
                if (mediaType === 'audio') {
                    try { remoteAudioTracks.delete(String(user.uid)); } catch { /* ignore */ }
                }
            });

            client.on('user-left', (user) => {
                try { remoteAudioTracks.delete(String(user.uid)); } catch { /* ignore */ }
                try { participants.delete(String(user.uid)); } catch { /* ignore */ }
                try { removeRemoteCard(user.uid); } catch { /* ignore */ }
                try { removeVoiceCard(user.uid); } catch { /* ignore */ }
                renderParticipants();
            });

            client.on('user-joined', (user) => {
                try { ensureRemoteParticipant(user && user.uid); } catch { /* ignore */ }
                if (callType === 'video') {
                    try { ensureRemoteCard(user && user.uid); } catch { /* ignore */ }
                } else {
                    try { ensureVoiceCard(user && user.uid); } catch { /* ignore */ }
                }
                setPhase('In call');
                stopOutgoingRing();
            });

            await client.join(app_id, channel, token, uid);

            // Best-effort: show other member names for 1:1 rooms even before they join.
            if (Array.isArray(memberUsernames) && memberUsernames.length) {
                // Keep 'You' and let presence updates fill the rest.
            }

            await announcePresence('join', uid);

            // Persist a chat marker that call started ONLY from caller.
            if (callRole === 'caller') {
                await postCallEvent('start');
            }

            // Local tracks
            showLoading('Starting microphone…');
            localTracks.audio = await AgoraRTC.createMicrophoneAudioTrack({
                AEC: true,
                AGC: true,
                ANS: true,
            });
            try { await localTracks.audio.setEnabled(true); } catch { /* ignore */ }

            if (callType === 'video') {
                try {
                    showLoading('Starting camera…');
                    localTracks.video = await AgoraRTC.createCameraVideoTrack();
                    const localContainer = document.getElementById('local-player');
                    if (localContainer) localTracks.video.play(localContainer);
                    showLoading('Publishing media…');
                    await client.publish([localTracks.audio, localTracks.video]);
                } catch (err) {
                    // Common on Windows/Chrome when testing multiple tabs on the same PC (camera already in use)
                    // or when permissions are denied.
                    setStatus('Camera not available. Joining audio-only. (Tip: only 1 tab/device can use the camera at a time)');
                    showLoading('Publishing audio…');
                    await client.publish([localTracks.audio]);
                }
            } else {
                showLoading('Publishing audio…');
                await client.publish([localTracks.audio]);
            }

            setStatus('Connected (mic published)');
            hideLoading();

            // Start free-limit countdown after we successfully join + publish.
            startFreeLimitCountdown();

            // If remote audio was blocked earlier, a tap will retry. If not blocked,
            // this is a no-op.
            tryPlayAllRemoteAudio();
        } catch (e) {
            hideLoading();
            setStatus('Error: ' + (e && e.message ? e.message : String(e)));
        }
    }

    join();

    // If user clicks End/Back button, try to send ended marker before leaving.
    const endBtn = document.querySelector('a[href="{% url 'chatroom' chatroom_name %}"]');
    if (endBtn) {
        endBtn.addEventListener('click', function () {
            if (endSent) return;
            endSent = true;
            stopOutgoingRing();
            postCallEvent('end');
        });
    }

    window.addEventListener('beforeunload', function () {
        if (remoteEnded || endSent) return;
        endSent = true;
        try {
            const uid = client && client.uid ? client.uid : 0;
            const body = new URLSearchParams();
            body.set('action', 'leave');
            body.set('type', callType);
            body.set('uid', String(uid || 0));
            navigator.sendBeacon(presenceUrl, body);
        } catch {
            // ignore
        }

        try {
            const body2 = new FormData();
            body2.append('csrfmiddlewaretoken', getCsrf());
            body2.append('action', 'end');
            body2.append('type', callType);
            navigator.sendBeacon(callEventUrl, body2);
        } catch {
            // ignore
        }
    });
})();
</script>
{% endcomment %}
{% endblock %}
