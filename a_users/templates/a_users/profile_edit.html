{% extends 'base.html' %}

{% block body_class %} vixo-profile-page{% endblock %}

{% block content %}
<wrapper class="block max-w-md mx-auto my-10 px-6">
    <div class="bg-gray-900/60 backdrop-blur p-8 rounded-2xl shadow-2xl border border-white/10 text-white">
        <h1 class="text-2xl font-extrabold mb-2 text-center bg-gradient-to-r from-purple-400 via-indigo-400 to-sky-400 bg-clip-text text-transparent">Edit profile</h1>
        <p class="text-center text-sm text-gray-400 mb-6">Update your avatar and profile details.</p>

        <div class="mb-6 rounded-xl border border-gray-800 bg-gray-950/30 p-4">
            <div class="text-sm font-semibold text-gray-200">Change username</div>
            <p class="mt-1 text-xs text-gray-400">
                First change is allowed anytime. After that, you can change again only after {{ username_cooldown_days }} days.
            </p>
            <div class="mt-2 text-sm text-gray-300">
                Current: <span class="text-gray-100 font-semibold">@{{ user.username }}</span>
            </div>
            {% if not username_can_change and username_next_available_at %}
                <div class="mt-2 text-xs text-amber-300">
                    You can change again after {{ username_next_available_at|date:"M d, Y" }}.
                </div>
            {% endif %}

            <form method="POST" action="{% url 'profile-edit' %}" class="mt-4 space-y-3" data-loading-text="Updating username…">
                {% csrf_token %}
                <input type="hidden" name="action" value="username" />

                <div class="flex flex-col gap-1">
                    <label class="text-xs text-gray-400">New username</label>
                    <div class="relative">
                        {{ username_form.username }}
                        <span id="username_status_icon" class="absolute right-3 top-1/2 -translate-y-1/2 text-sm hidden" aria-hidden="true"></span>
                    </div>
                    {% if username_form.username.errors %}
                        <span class="text-red-500 text-xs">{{ username_form.username.errors|first }}</span>
                    {% endif %}
                    <div class="text-[11px] text-gray-500">Allowed: letters, numbers, underscore, dot (3–30 chars).</div>
                    <div id="username_status_text" class="text-[11px] text-gray-500"></div>
                </div>

                <button
                    type="submit"
                    id="username_submit_btn"
                    class="w-full bg-gray-800 hover:bg-gray-700 text-white rounded-lg px-3 py-2 text-sm transition-colors"
                    {% if not username_can_change %}disabled style="opacity:.55;cursor:not-allowed"{% endif %}
                >
                    Update username
                </button>
            </form>
        </div>

        <form method="POST" action="{% url 'profile-edit' %}" enctype="multipart/form-data" class="space-y-4" data-loading-text="Saving changes…">
            {% csrf_token %}

            {% for field in form %}
                {% if field.name == 'image' %}
                    <div class="flex flex-col gap-2">
                        <label class="text-sm font-semibold text-gray-300">Current avatar</label>
                        <div class="flex items-center gap-3">
                            <img id="current_avatar_preview" src="{{ profile.avatar }}" alt="Current avatar" class="w-16 h-16 rounded-full object-cover border border-gray-700" />
                            <div class="text-xs text-gray-400">Choose a new image to update your avatar.</div>
                        </div>

                        <label class="text-sm font-semibold text-gray-300 mt-2">{{ field.label }}</label>
                        {{ field }}
                        {% if field.errors %}
                            <span class="text-red-500 text-xs">{{ field.errors|first }}</span>
                        {% endif %}
                    </div>
                {% elif field.name == 'cover_image' %}
                    <div class="flex flex-col gap-2">
                        <label class="text-sm font-semibold text-gray-300">Profile background</label>
                        <div class="rounded-xl border border-white/10 bg-gray-950/30 overflow-hidden">
                            <div class="h-24 relative">
                                {% if profile.cover_url %}
                                    <img src="{{ profile.cover_url }}" alt="Current background" class="absolute inset-0 w-full h-full object-cover" />
                                {% else %}
                                    <div class="absolute inset-0 bg-gradient-to-r from-purple-600/40 via-indigo-600/30 to-sky-600/40"></div>
                                {% endif %}
                                <div class="absolute inset-0 bg-gradient-to-b from-black/10 via-black/20 to-black/60"></div>
                            </div>
                            <div class="px-4 py-3 text-xs text-gray-400">Upload a custom background image (max 2MB).</div>
                        </div>

                        <label class="text-sm font-semibold text-gray-300 mt-2">{{ field.label }}</label>
                        {{ field }}
                        {% if field.errors %}
                            <span class="text-red-500 text-xs">{{ field.errors|first }}</span>
                        {% endif %}
                    </div>
                {% else %}
                    <div class="flex flex-col gap-1">
                        <label class="text-sm font-semibold text-gray-300">{{ field.label }}</label>
                        {{ field }}
                        {% if field.errors %}
                            <span class="text-red-500 text-xs">{{ field.errors|first }}</span>
                        {% endif %}
                    </div>
                {% endif %}
            {% endfor %}

            <div class="flex items-center gap-3 pt-4">
                <button type="submit" class="flex-1 bg-gradient-to-r from-purple-500 via-indigo-500 to-sky-500 hover:from-purple-400 hover:via-indigo-400 hover:to-sky-400 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Save changes
                </button>
                <a href="{% url 'profile' %}" class="flex-1 text-center bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Cancel
                </a>
            </div>
        </form>
    </div>

        <!-- Avatar crop modal (opens after selecting an image) -->
        <div id="avatar_crop_modal" class="hidden fixed inset-0 z-50" aria-hidden="true">
                <div class="absolute inset-0 bg-black/70"></div>
                <div class="relative min-h-screen flex items-center justify-center px-4 py-8">
                        <div class="w-full max-w-md bg-gray-800 rounded-2xl shadow-2xl border border-gray-700 overflow-hidden">
                                <div class="flex items-center justify-between px-5 py-4 border-b border-gray-700">
                                        <div class="text-white font-bold">Crop image</div>
                                        <button id="avatar_crop_close" type="button" class="text-gray-300 hover:text-white px-2 py-1">✕</button>
                                </div>

                                <div class="p-5">
                                        <div class="text-xs text-gray-400 mb-3">Drag to position • Use zoom</div>

                                        <div class="mx-auto w-[min(20rem,85vw)] max-w-full">
                                            <div id="avatar_crop_area" class="relative w-[min(20rem,85vw)] h-[min(20rem,85vw)] max-w-full bg-gray-900/40 border border-gray-700 rounded-2xl overflow-hidden touch-none select-none">
                                                        <img id="avatar_crop_img" alt="Crop preview" class="absolute left-1/2 top-1/2 will-change-transform pointer-events-none max-w-none max-h-none" />
                                                        <div aria-hidden="true" class="absolute inset-0 ring-1 ring-white/10"></div>
                                                </div>
                                        </div>

                                        <div class="mt-4">
                                                <label class="text-xs text-gray-400">Zoom</label>
                                                <input id="avatar_crop_zoom" type="range" min="1" max="3" step="0.01" value="1" class="w-full" />
                                        </div>

                                        <div class="mt-5 flex items-center gap-3">
                                                <button id="avatar_crop_cancel" type="button" class="flex-1 text-center bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cancel</button>
                                                <button id="avatar_crop_apply" type="button" class="flex-1 bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Apply</button>
                                        </div>
                                </div>
                        </div>
                </div>
        </div>
</wrapper>
{% endblock %}

{% block extra_body %}
{{ block.super }}
<script>
(() => {
    // Username availability check (2s debounce)
    const usernameInput = document.getElementById('id_username') || document.querySelector('input[name="username"]');
    const usernameIcon = document.getElementById('username_status_icon');
    const usernameStatus = document.getElementById('username_status_text');
    const usernameBtn = document.getElementById('username_submit_btn');
    const usernameCheckUrl = "{% url 'username-check' %}";
    const usernameCanChangeNow = {{ username_can_change|yesno:"true,false" }};
    const currentUsername = "{{ user.username }}";

    const setBtnEnabled = (enabled) => {
        if (!usernameBtn) return;
        if (!usernameCanChangeNow) {
            usernameBtn.disabled = true;
            return;
        }
        usernameBtn.disabled = !enabled;
        if (usernameBtn.disabled) {
            usernameBtn.style.opacity = '.55';
            usernameBtn.style.cursor = 'not-allowed';
        } else {
            usernameBtn.style.opacity = '';
            usernameBtn.style.cursor = '';
        }
    };

    const setState = (kind, message) => {
        if (!usernameIcon || !usernameStatus) return;
        usernameIcon.classList.remove('hidden');
        usernameIcon.classList.remove('text-emerald-400', 'text-red-400', 'text-gray-400');

        if (kind === 'ok') {
            usernameIcon.textContent = '✓';
            usernameIcon.classList.add('text-emerald-400');
        } else if (kind === 'bad') {
            usernameIcon.textContent = '✕';
            usernameIcon.classList.add('text-red-400');
        } else {
            usernameIcon.textContent = '…';
            usernameIcon.classList.add('text-gray-400');
        }
        usernameStatus.textContent = message || '';
    };

    const clearState = () => {
        if (usernameIcon) usernameIcon.classList.add('hidden');
        if (usernameStatus) usernameStatus.textContent = '';
    };

    if (usernameInput && usernameIcon && usernameStatus && usernameBtn) {
        let timer = null;
        let requestSeq = 0;

        // Require a successful check before enabling.
        setBtnEnabled(false);

        const runCheck = async () => {
            const val = (usernameInput.value || '').trim();
            if (!val) {
                clearState();
                setBtnEnabled(false);
                return;
            }
            if (val === currentUsername) {
                setState('bad', 'That is already your username.');
                setBtnEnabled(false);
                return;
            }
            if (!usernameCanChangeNow) {
                setState('bad', 'Cooldown active.');
                setBtnEnabled(false);
                return;
            }

            const mySeq = ++requestSeq;
            setState('loading', 'Checking…');
            try {
                const resp = await fetch(`${usernameCheckUrl}?u=${encodeURIComponent(val)}`, { credentials: 'same-origin' });
                if (mySeq !== requestSeq) return;
                if (!resp.ok) {
                    setState('bad', 'Could not check right now.');
                    setBtnEnabled(false);
                    return;
                }
                const data = await resp.json();
                if (mySeq !== requestSeq) return;
                if (data && data.available) {
                    setState('ok', 'You can use this username');
                    setBtnEnabled(true);
                } else {
                    setState('bad', (data && data.message) ? data.message : 'Username not available');
                    setBtnEnabled(false);
                }
            } catch {
                if (mySeq !== requestSeq) return;
                setState('bad', 'Could not check right now.');
                setBtnEnabled(false);
            }
        };

        const schedule = () => {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            const val = (usernameInput.value || '').trim();
            if (!val) {
                clearState();
                setBtnEnabled(false);
                return;
            }
            timer = setTimeout(runCheck, 2000);
        };

        usernameInput.addEventListener('input', schedule);
        usernameInput.addEventListener('blur', () => {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            runCheck();
        });
    }

    const fileInput = document.getElementById('id_image') || document.querySelector('input[type="file"][name="image"]');
    if (!fileInput) return;

    const modal = document.getElementById('avatar_crop_modal');
    const closeBtn = document.getElementById('avatar_crop_close');
    const cancelBtn = document.getElementById('avatar_crop_cancel');
    const applyBtn = document.getElementById('avatar_crop_apply');
    const cropArea = document.getElementById('avatar_crop_area');
    const cropImg = document.getElementById('avatar_crop_img');
    const zoomInput = document.getElementById('avatar_crop_zoom');
    const avatarPreview = document.getElementById('current_avatar_preview');

    if (!modal || !closeBtn || !cancelBtn || !applyBtn || !cropArea || !cropImg || !zoomInput) return;

    const OUT_SIZE = 512;

    const getCropSize = () => {
        const rect = cropArea.getBoundingClientRect();
        const size = Math.max(1, Math.round(Math.min(rect.width || 0, rect.height || 0)));
        return size;
    };

    let objectUrl = null;
    let imgEl = null;
    let imgW = 0;
    let imgH = 0;
    let baseScale = 1;
    let zoom = 1;
    let offsetX = 0;
    let offsetY = 0;
    let dragging = false;
    let startX = 0;
    let startY = 0;
    let startOffsetX = 0;
    let startOffsetY = 0;
    let originalFile = null;

    const open = () => {
        modal.classList.remove('hidden');
        modal.setAttribute('aria-hidden', 'false');
    };

    const close = () => {
        modal.classList.add('hidden');
        modal.setAttribute('aria-hidden', 'true');
    };

    const cleanupObjectUrl = () => {
        if (objectUrl) {
            try { URL.revokeObjectURL(objectUrl); } catch {}
            objectUrl = null;
        }
    };

    const clampOffsets = () => {
        const CROP_SIZE = getCropSize();
        const scale = baseScale * zoom;
        const scaledW = imgW * scale;
        const scaledH = imgH * scale;
        const halfCrop = CROP_SIZE / 2;
        const maxX = Math.max(0, (scaledW / 2) - halfCrop);
        const maxY = Math.max(0, (scaledH / 2) - halfCrop);
        offsetX = Math.min(maxX, Math.max(-maxX, offsetX));
        offsetY = Math.min(maxY, Math.max(-maxY, offsetY));
    };

    const renderTransform = () => {
        clampOffsets();
        const scale = baseScale * zoom;
        cropImg.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
    };

    const syncCropSize = () => {
        if (!imgEl) return;
        const CROP_SIZE = getCropSize();
        baseScale = Math.max(CROP_SIZE / imgW, CROP_SIZE / imgH);
        renderTransform();
    };

    const loadImageFromFile = (file) => {
        cleanupObjectUrl();
        originalFile = file;
        objectUrl = URL.createObjectURL(file);

        return new Promise((resolve, reject) => {
            const im = new Image();
            im.onload = () => resolve(im);
            im.onerror = reject;
            im.src = objectUrl;
        });
    };

    const resetStateForImage = (im) => {
        imgEl = im;
        imgW = im.naturalWidth || im.width || 1;
        imgH = im.naturalHeight || im.height || 1;

        baseScale = Math.max(getCropSize() / imgW, getCropSize() / imgH);
        zoom = 1;
        zoomInput.value = '1';
        offsetX = 0;
        offsetY = 0;

        cropImg.src = im.src;
        cropImg.style.width = imgW + 'px';
        cropImg.style.height = imgH + 'px';
        renderTransform();
    };

    const clearSelection = () => {
        fileInput.value = '';
        originalFile = null;
        cleanupObjectUrl();
    };

    fileInput.addEventListener('change', async () => {
        const file = fileInput.files && fileInput.files[0];
        if (!file) return;
        if (!file.type || !file.type.startsWith('image/')) {
            clearSelection();
            return;
        }

        try {
            const im = await loadImageFromFile(file);
            open();
            // Wait for the modal to be visible so cropArea has a real size.
            requestAnimationFrame(() => {
                resetStateForImage(im);
                syncCropSize();
                setTimeout(syncCropSize, 50);
            });
        } catch {
            clearSelection();
        }
    });

    window.addEventListener('resize', () => {
        if (modal.classList.contains('hidden')) return;
        syncCropSize();
    });

    zoomInput.addEventListener('input', () => {
        zoom = Math.max(1, Math.min(3, parseFloat(zoomInput.value || '1') || 1));
        renderTransform();
    });

    const onPointerDown = (e) => {
        if (!imgEl) return;
        dragging = true;
        cropArea.setPointerCapture?.(e.pointerId);
        startX = e.clientX;
        startY = e.clientY;
        startOffsetX = offsetX;
        startOffsetY = offsetY;
    };

    const onPointerMove = (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        offsetX = startOffsetX + dx;
        offsetY = startOffsetY + dy;
        renderTransform();
    };

    const onPointerUp = () => {
        dragging = false;
    };

    cropArea.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);

    const applyCrop = async () => {
        if (!imgEl || !originalFile) return;

        const CROP_SIZE = getCropSize();

        // Render to canvas
        const canvas = document.createElement('canvas');
        canvas.width = OUT_SIZE;
        canvas.height = OUT_SIZE;

        const ctx = canvas.getContext('2d', { alpha: true });
        if (!ctx) return;

        const scale = baseScale * zoom;
        const ratio = OUT_SIZE / CROP_SIZE;

        ctx.clearRect(0, 0, OUT_SIZE, OUT_SIZE);
        ctx.save();
        ctx.translate(OUT_SIZE / 2 + offsetX * ratio, OUT_SIZE / 2 + offsetY * ratio);
        ctx.scale(scale * ratio, scale * ratio);
        ctx.drawImage(imgEl, -imgW / 2, -imgH / 2);
        ctx.restore();

        const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/png', 0.92));
        if (!blob) return;

        const baseName = (originalFile.name || 'avatar').replace(/\.[^/.]+$/, '');
        const croppedFile = new File([blob], `${baseName}-cropped.png`, { type: 'image/png' });

        const dt = new DataTransfer();
        dt.items.add(croppedFile);
        fileInput.files = dt.files;

        if (avatarPreview) {
            try {
                const previewUrl = URL.createObjectURL(croppedFile);
                avatarPreview.src = previewUrl;
                // Let the browser keep this url until next change; no need to revoke immediately.
            } catch {}
        }

        close();
    };

    const cancelCrop = () => {
        close();
        clearSelection();
    };

    closeBtn.addEventListener('click', (e) => {
        e.preventDefault();
        cancelCrop();
    });
    cancelBtn.addEventListener('click', (e) => {
        e.preventDefault();
        cancelCrop();
    });
    applyBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        await applyCrop();
    });

    modal.addEventListener('click', (e) => {
        if (e.target === modal || e.target === modal.firstElementChild) cancelCrop();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !modal.classList.contains('hidden')) cancelCrop();
    });
})();
</script>
</wrapper>
{% endblock %}
